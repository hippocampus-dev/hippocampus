// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: messages.sql

package db

import (
	"context"
	"database/sql"
	"time"
)

const deleteMessage = `-- name: DeleteMessage :exec
DELETE FROM encrypted_messages
WHERE channel_name = ? AND message_ts = ?
`

type DeleteMessageParams struct {
	ChannelName string `json:"channel_name"`
	MessageTs   string `json:"message_ts"`
}

func (q *Queries) DeleteMessage(ctx context.Context, arg DeleteMessageParams) error {
	_, err := q.db.ExecContext(ctx, deleteMessage, arg.ChannelName, arg.MessageTs)
	return err
}

const getMessagesByChannelName = `-- name: GetMessagesByChannelName :many
SELECT
    id,
    channel_name,
    message_ts,
    thread_ts,
    salt,
    encrypted_data,
    timestamp,
    created_at
FROM encrypted_messages
WHERE channel_name = ?
  AND (thread_ts IS NULL OR thread_ts = message_ts)
  AND (
    CAST(? AS DATETIME) IS NULL
    OR timestamp >= CASE
      WHEN CAST(? AS SIGNED) = 1
      THEN CAST(? AS DATETIME)
      ELSE DATE_ADD(CAST(? AS DATETIME), INTERVAL 1 MICROSECOND)
    END
  )
  AND (
    CAST(? AS DATETIME) IS NULL
    OR timestamp <= CASE
      WHEN CAST(? AS SIGNED) = 1
      THEN CAST(? AS DATETIME)
      ELSE DATE_SUB(CAST(? AS DATETIME), INTERVAL 1 MICROSECOND)
    END
  )
ORDER BY timestamp DESC
LIMIT ? OFFSET ?
`

type GetMessagesByChannelNameParams struct {
	ChannelName string        `json:"channel_name"`
	SinceTime   sql.NullTime  `json:"since_time"`
	Inclusive   sql.NullInt64 `json:"inclusive"`
	SinceTime_2 sql.NullTime  `json:"since_time_2"`
	SinceTime_3 sql.NullTime  `json:"since_time_3"`
	UntilTime   sql.NullTime  `json:"until_time"`
	Inclusive_2 sql.NullInt64 `json:"inclusive_2"`
	UntilTime_2 sql.NullTime  `json:"until_time_2"`
	UntilTime_3 sql.NullTime  `json:"until_time_3"`
	Limit       int32         `json:"limit"`
	Offset      int32         `json:"offset"`
}

// Returns only parent messages (where thread_ts is NULL or equals message_ts)
// to match Slack's conversations.history API behavior
// Supports inclusive parameter for timestamp boundaries
func (q *Queries) GetMessagesByChannelName(ctx context.Context, arg GetMessagesByChannelNameParams) ([]EncryptedMessage, error) {
	rows, err := q.db.QueryContext(ctx, getMessagesByChannelName,
		arg.ChannelName,
		arg.SinceTime,
		arg.Inclusive,
		arg.SinceTime_2,
		arg.SinceTime_3,
		arg.UntilTime,
		arg.Inclusive_2,
		arg.UntilTime_2,
		arg.UntilTime_3,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []EncryptedMessage{}
	for rows.Next() {
		var i EncryptedMessage
		if err := rows.Scan(
			&i.ID,
			&i.ChannelName,
			&i.MessageTs,
			&i.ThreadTs,
			&i.Salt,
			&i.EncryptedData,
			&i.Timestamp,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMessagesByThreadTs = `-- name: GetMessagesByThreadTs :many
SELECT
    id,
    channel_name,
    message_ts,
    thread_ts,
    salt,
    encrypted_data,
    timestamp,
    created_at
FROM encrypted_messages
WHERE channel_name = ?
  AND (thread_ts = ? OR (message_ts = ? AND (thread_ts IS NULL OR thread_ts = message_ts)))
  AND (
    CAST(? AS DATETIME) IS NULL
    OR timestamp >= CASE
      WHEN CAST(? AS SIGNED) = 1
      THEN CAST(? AS DATETIME)
      ELSE DATE_ADD(CAST(? AS DATETIME), INTERVAL 1 MICROSECOND)
    END
  )
  AND (
    CAST(? AS DATETIME) IS NULL
    OR timestamp <= CASE
      WHEN CAST(? AS SIGNED) = 1
      THEN CAST(? AS DATETIME)
      ELSE DATE_SUB(CAST(? AS DATETIME), INTERVAL 1 MICROSECOND)
    END
  )
ORDER BY timestamp ASC
LIMIT ? OFFSET ?
`

type GetMessagesByThreadTsParams struct {
	ChannelName string         `json:"channel_name"`
	ThreadTs    sql.NullString `json:"thread_ts"`
	MessageTs   string         `json:"message_ts"`
	SinceTime   sql.NullTime   `json:"since_time"`
	Inclusive   sql.NullInt64  `json:"inclusive"`
	SinceTime_2 sql.NullTime   `json:"since_time_2"`
	SinceTime_3 sql.NullTime   `json:"since_time_3"`
	UntilTime   sql.NullTime   `json:"until_time"`
	Inclusive_2 sql.NullInt64  `json:"inclusive_2"`
	UntilTime_2 sql.NullTime   `json:"until_time_2"`
	UntilTime_3 sql.NullTime   `json:"until_time_3"`
	Limit       int32          `json:"limit"`
	Offset      int32          `json:"offset"`
}

// Returns all messages in a thread including the parent message
// to match Slack's conversations.replies API behavior
// Supports inclusive parameter for timestamp boundaries
func (q *Queries) GetMessagesByThreadTs(ctx context.Context, arg GetMessagesByThreadTsParams) ([]EncryptedMessage, error) {
	rows, err := q.db.QueryContext(ctx, getMessagesByThreadTs,
		arg.ChannelName,
		arg.ThreadTs,
		arg.MessageTs,
		arg.SinceTime,
		arg.Inclusive,
		arg.SinceTime_2,
		arg.SinceTime_3,
		arg.UntilTime,
		arg.Inclusive_2,
		arg.UntilTime_2,
		arg.UntilTime_3,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []EncryptedMessage{}
	for rows.Next() {
		var i EncryptedMessage
		if err := rows.Scan(
			&i.ID,
			&i.ChannelName,
			&i.MessageTs,
			&i.ThreadTs,
			&i.Salt,
			&i.EncryptedData,
			&i.Timestamp,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertMessage = `-- name: InsertMessage :exec
INSERT INTO encrypted_messages (
    channel_name,
    message_ts,
    thread_ts,
    salt,
    encrypted_data,
    timestamp
) VALUES (?, ?, ?, ?, ?, ?)
`

type InsertMessageParams struct {
	ChannelName   string         `json:"channel_name"`
	MessageTs     string         `json:"message_ts"`
	ThreadTs      sql.NullString `json:"thread_ts"`
	Salt          []byte         `json:"salt"`
	EncryptedData []byte         `json:"encrypted_data"`
	Timestamp     time.Time      `json:"timestamp"`
}

func (q *Queries) InsertMessage(ctx context.Context, arg InsertMessageParams) error {
	_, err := q.db.ExecContext(ctx, insertMessage,
		arg.ChannelName,
		arg.MessageTs,
		arg.ThreadTs,
		arg.Salt,
		arg.EncryptedData,
		arg.Timestamp,
	)
	return err
}

const updateMessage = `-- name: UpdateMessage :exec
UPDATE encrypted_messages
SET thread_ts = ?,
    salt = ?,
    encrypted_data = ?,
    timestamp = ?
WHERE channel_name = ? AND message_ts = ?
`

type UpdateMessageParams struct {
	ThreadTs      sql.NullString `json:"thread_ts"`
	Salt          []byte         `json:"salt"`
	EncryptedData []byte         `json:"encrypted_data"`
	Timestamp     time.Time      `json:"timestamp"`
	ChannelName   string         `json:"channel_name"`
	MessageTs     string         `json:"message_ts"`
}

func (q *Queries) UpdateMessage(ctx context.Context, arg UpdateMessageParams) error {
	_, err := q.db.ExecContext(ctx, updateMessage,
		arg.ThreadTs,
		arg.Salt,
		arg.EncryptedData,
		arg.Timestamp,
		arg.ChannelName,
		arg.MessageTs,
	)
	return err
}
